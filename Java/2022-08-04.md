![[화면 캡처 2022-08-04 111810.png]]

## 지역변수(local variable)
특정 method 내에서만 사용되는 변수
main 메소드는 i, j, k => local varibale
max 메소드는 result
</br>

## 매개변수(parameter variable) 
method의 formal parameter list
max method는 num1, num2
</br>

## 참조변수 비교

```java
public class StringEqulasEx {

	public static void main(String[] args) {
		String strVar1 = "신민철";
		String strVar2 = "신민철";
		
		if (strVar1 == strVar2) {
			System.out.println("strVar1과 strVar2의 참조가 같음(힙 메모리의 주소가 같음)");
		} else {
			System.out.println("strVar1과 strVar2의 참조가 같음(힙 메모리의 주소가 틀림)");
		}
		System.out.println("strVar1 힙메모리 주소: "+System.identityHashCode(strVar1));
		System.out.println("strVar2 힙메모리 주소: "+System.identityHashCode(strVar2));
		

		if (strVar1.equals(strVar2)) {
			System.out.println("strVar1과 strVar2의 문자열이 같음");
		}
		
		String strVar3 = new String("신민철");
		String strVar4 = new String("신민철");
		
		if (strVar3 == strVar4) {
			System.out.println("strVar3과 strVar4의 참조가 같음(힙 메모리의 주소가 같음)");
		} else {
			System.out.println("strVar3과 strVar4의 참조가 같음(힙 메모리의 주소가 틀림)");
		}

		if (strVar3.equals(strVar4)) {
			System.out.println("strVar3과 strVar4의 문자열이 같음");
		}
		if (name == null) {
			System.out.println("힙메모리에 저장된 데이터가 없다는 의미");
		}	
	}
}
```
</br>

## 배열(array)
같은 타입의 데이터를 연속된 공간에 저장하는 자료구조이다. 각 데이터의 저장 위치는 인덱스를 부여해 접근한다. 

배열 선언
```
타입[] 변수명;
타입[] 변수명 = {0,0,0,0,0};

타입[] 변수 = new 타입[길이];
```

접근
```
배열이름[인덱스]
```

```java
public class ArrayBasic {

	public static void main(String[] args) {
		// 1. 배열 선언하면서 초기값 {} 사용 방법
		int[] arr = { 10, 20, 30, 40 };

		System.out.println("arr 첫번째 원소 : " + arr[0]);
		System.out.println("arr 두번째 원소 : " + arr[1]);
		System.out.println("arr 세번째 원소 : " + arr[2]);
		System.out.println("arr 네번째 원소 : " + arr[3]);
		System.out.println("arr 전체 배열원소 갯수: " + arr.length);

		// 2. 배열만 선언하고 나중에 초기값 넣는 방법
		int[] arr3;
		// new + data type
		arr3 = new int[] { 5, 6, 7, 8, 9 };
		System.out.println("arr3 첫번째 원소 : " + arr3[0]);
		System.out.println("arr3 두번째 원소 : " + arr3[1]);
		System.out.println("arr3 세번째 원소 : " + arr3[2]);
		System.out.println("arr3 네번째 원소 : " + arr3[3]);
		System.out.println("arr3 다섯번째 원소 : " + arr3[4]);
		System.out.println("arr3 전체 배열원소 객수 : " + arr3.length);

		// 3. 배열 원소의 값이 없는 배열 크기만 생성
		int[] arr4 = new int[4]; // 4개 원소를 가진 배열을 메모리에 생성
		arr4[0] = 10;
		arr4[1] = 20;
		arr4[2] = 30;
		arr4[3] = 40;
		System.out.println("arr4 전체 배열원소 갯수 : " + arr4.length);

	}
}
```

결과
```
arr 첫번째 원소 : 10
arr 두번째 원소 : 20
arr 세번째 원소 : 30
arr 네번째 원소 : 40
arr 전체 배열원소 갯수: 4
```
</br>

### for문에 배열 사용 ( + 향상된 for문)
```java
public class ArrayBasic2 {

	public static void main(String[] args) {
		int sum = 0;
		int[] arr = { 10, 20, 30, 40, 50, 60 };
		double[] arr2 = { 1.0, 2.0, 3.0, 4.0 };

		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
			System.out.println("arr[" + i + "] : " + arr[i]);
		}
		
		for (int i = 0; i < arr2.length; i++) {
			System.out.println("arr2[" + i + "] : " + arr2[i]);
		}
		System.out.println();
		// 향상된 for문 (배열 등 여러 원소를 가진 type에서 사용 가능)
		// arr 배열에서 첫번째 원소부터 마지막 원소의 값을 차례로 element에 넣어줌
		for (int element : arr) {
			System.out.println(element);
		}
		
		for (double element : arr2) {
			System.out.println(element);
		}
	}
}
```
결과
```
arr[0] : 10
arr[1] : 20
arr[2] : 30
arr[3] : 40
arr[4] : 50
arr[5] : 60
arr2[0] : 1.0
arr2[1] : 2.0
arr2[2] : 3.0
arr2[3] : 4.0

10
20
30
40
50
60
1.0
2.0
3.0
4.0
```
</br>

#### 배열 입력받기
```java
public class ArrayBasic3 {

	public static void main(String[] args) {
		double[] myList;

		Scanner input = new Scanner(System.in);
		System.out.println("배열 전체 크기를 입력하세요.");
		int arrayLenght = input.nextInt();

		myList = new double[arrayLenght];

		for (int i = 0; i < myList.length; i++) {
			System.out.println((i + 1) + "번째 원소를 입력하세요.");
			myList[i] = input.nextDouble();
		}

		for (int i = 0; i < myList.length; i++) {
			System.out.println("myList[" + i + "] : " + myList[i]);
		}
	}
}
```
결과
```
배열 전체 크기를 입력하세요.
5
1번째 원소를 입력하세요.
1
2번째 원소를 입력하세요.
2
3번째 원소를 입력하세요.
3
4번째 원소를 입력하세요.
4
5번째 원소를 입력하세요.
5
myList[0] : 1.0
myList[1] : 2.0
myList[2] : 3.0
myList[3] : 4.0
myList[4] : 5.0
```
</br>

#### random하게 배열 원소 초기값(0~100 실수) 주기
```java
public class ArrayBasic4 {

	public static void main(String[] args) {
		double[] myList = new double[10];

		for (int i = 0; i < myList.length; i++) {
			myList[i] = Math.random() * 100;
		}
		
		for (double element : myList) {
			System.out.println(element);
		}
	}
}
```
</br>

#### 문자열 배열
```java
public class ArrayBasic8 {

	public static void main(String[] args) {
		String[] months = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

		Scanner input = new Scanner(System.in);

		System.out.println("달력 숫자를 입력하세요.(1 ~ 12사이)");
		int month = input.nextInt();

		System.out.println("이번 달은 " + months[month - 1] + "입니다.");
	}
}
```
</br>

#### System.arraycopy 메소드
```java
// 배열 복사 (A배열 원소들의 값 전체를 B배열 원소들로 값을 복사)
public class ArrayCopy {

	public static void main(String[] args) {
		int[] sourceArray = { 2, 3, 1, 5, 10 };
		int[] targetArray = new int[sourceArray.length];

//		// 복사 방법 1: for문을 사용하여 단순 복사
//		for (int i = 0; i < sourceArray.length; i++) {
//			targetArray[i] = sourceArray[i];
//		}
		
		// 복사 방법 2: System.arraycopy method 이용
		// a배열의 인덱스 0~에, b배열의 인덱스 0~을 길이만큼 복사
		System.arraycopy(sourceArray, 0, targetArray, 0, sourceArray.length);

		for (int i = 0; i < targetArray.length; i++) {
			System.out.println("targetArray[" + i + "] = " + targetArray[i]);
		}
	}
}
```
결과
```
targetArray[0] = 2
targetArray[1] = 3
targetArray[2] = 1
targetArray[3] = 5
targetArray[4] = 10
```
</br>

#### 배열 뒤집기
```java
public class ArrayReverse {

	public static void main(String[] args) {
		int[] list = { 1, 2, 3, 4, 5 };

		System.out.print("reverse 하기 전: ");
		for (int i = 0; i < list.length; i++) {
			System.out.print(list[i] + " ");
		}
		System.out.println();

		list = reverse(list);

		System.out.print("reverse 한 후 : ");
		for (int i = 0; i < list.length; i++) {
			System.out.print(list[i] + " ");
		}
	}

	// return type: array
	public static int[] reverse(int[] list) {
		int[] newList = new int[list.length];

		for (int i = 0; i < list.length; i++) {
			newList[i] = list[list.length - 1 - i];	// 뒤집기
		}
		return newList;
	}
}
```
결과
```
reverse 하기 전: 1 2 3 4 5 
reverse 한 후 : 5 4 3 2 1 
```


